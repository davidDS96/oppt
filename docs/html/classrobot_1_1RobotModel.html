<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>OPPT: robot::RobotModel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OPPT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerobot.html">robot</a></li><li class="navelem"><a class="el" href="classrobot_1_1RobotModel.html">RobotModel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrobot_1_1RobotModel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">robot::RobotModel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="RobotModel_8hpp_source.html">RobotModel.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for robot::RobotModel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrobot_1_1RobotModel.png" usemap="#robot::RobotModel_map" alt=""/>
  <map id="robot::RobotModel_map" name="robot::RobotModel_map">
<area href="classshared_1_1ModelWithProgramOptions.html" alt="shared::ModelWithProgramOptions" shape="rect" coords="0,56,207,80"/>
<area href="classabt_1_1Model.html" alt="abt::Model" shape="rect" coords="0,0,207,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab8f32daed872cd76554e069ea6e135a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#ab8f32daed872cd76554e069ea6e135a6">RobotModel</a> (RandomEnginePtr randGen, std::unique_ptr&lt; <a class="el" href="structoppt_1_1ABTExtendedOptions.html">ABTExtendedOptions</a> &gt; options)</td></tr>
<tr class="separator:ab8f32daed872cd76554e069ea6e135a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a57d67a3decc10f045aa58efd1f23c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56a57d67a3decc10f045aa58efd1f23c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_NO_COPY_OR_MOVE</b> (<a class="el" href="classrobot_1_1RobotModel.html">RobotModel</a>)</td></tr>
<tr class="separator:a56a57d67a3decc10f045aa58efd1f23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa75446992255a6b4d81667dd7ebebb"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#a4fa75446992255a6b4d81667dd7ebebb">sampleAnInitState</a> () override</td></tr>
<tr class="separator:a4fa75446992255a6b4d81667dd7ebebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd8c83847ada3199c1d4bf87ade87d4"><td class="memItemLeft" align="right" valign="top">virtual Model::StepResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#a8bd8c83847ada3199c1d4bf87ade87d4">generateStep</a> (<a class="el" href="classabt_1_1Point.html">abt::State</a> const &amp;state, <a class="el" href="classabt_1_1Point.html">abt::Action</a> const &amp;action) override</td></tr>
<tr class="separator:a8bd8c83847ada3199c1d4bf87ade87d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430074b87e12d15523b2ee8ab5573d85"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#a430074b87e12d15523b2ee8ab5573d85">sampleStateUninformed</a> () override</td></tr>
<tr class="separator:a430074b87e12d15523b2ee8ab5573d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc1463779eced9f629dc4b98132468d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#a3bc1463779eced9f629dc4b98132468d">isTerminal</a> (<a class="el" href="classabt_1_1Point.html">abt::State</a> const &amp;state) override</td></tr>
<tr class="separator:a3bc1463779eced9f629dc4b98132468d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e3429befd348efaf10320a329106d2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#a94e3429befd348efaf10320a329106d2">isValid</a> (<a class="el" href="classabt_1_1Point.html">abt::State</a> const &amp;state) override</td></tr>
<tr class="separator:a94e3429befd348efaf10320a329106d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b9a8f9d4a4757b4f856cbcc4204655"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#af4b9a8f9d4a4757b4f856cbcc4204655">generateNextState</a> (<a class="el" href="classabt_1_1Point.html">abt::State</a> const &amp;state, <a class="el" href="classabt_1_1Point.html">abt::Action</a> const &amp;action, <a class="el" href="classabt_1_1TransitionParameters.html">abt::TransitionParameters</a> const *) override</td></tr>
<tr class="separator:af4b9a8f9d4a4757b4f856cbcc4204655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08c7fc9a544c84643904ba1ca924f02"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1Point.html">abt::Observation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#aa08c7fc9a544c84643904ba1ca924f02">generateObservation</a> (<a class="el" href="classabt_1_1Point.html">abt::State</a> const *, <a class="el" href="classabt_1_1Point.html">abt::Action</a> const &amp;action, <a class="el" href="classabt_1_1TransitionParameters.html">abt::TransitionParameters</a> const *, <a class="el" href="classabt_1_1Point.html">abt::State</a> const &amp;nextState) override</td></tr>
<tr class="separator:aa08c7fc9a544c84643904ba1ca924f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e64f248c714fc9278ba1840019f9439"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="defs_8hpp.html#abf68352991692944f34952d0069463bc">FloatType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#a5e64f248c714fc9278ba1840019f9439">generateReward</a> (<a class="el" href="classabt_1_1Point.html">abt::State</a> const &amp;state, <a class="el" href="classabt_1_1Point.html">abt::Action</a> const &amp;action, <a class="el" href="classabt_1_1TransitionParameters.html">abt::TransitionParameters</a> const *, <a class="el" href="classabt_1_1Point.html">abt::State</a> const *) override</td></tr>
<tr class="separator:a5e64f248c714fc9278ba1840019f9439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dfa57e38e123c67fdae99043626d15"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1TransitionParameters.html">abt::TransitionParameters</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#a64dfa57e38e123c67fdae99043626d15">generateTransition</a> (<a class="el" href="classabt_1_1Point.html">abt::State</a> const &amp;state, <a class="el" href="classabt_1_1Point.html">abt::Action</a> const &amp;action) override</td></tr>
<tr class="separator:a64dfa57e38e123c67fdae99043626d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b393af56b39f6212bafa9b6baf12e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99b393af56b39f6212bafa9b6baf12e0"></a>
<a class="el" href="namespaceoppt.html#ac6dea77f8ec8752ebcafaa953adb9ebf">oppt::PropagationResultSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>makeNextState</b> (const <a class="el" href="namespaceoppt.html#a63acd976c69e1f077392ae04f85ee5b5">oppt::RobotStateSharedPtr</a> &amp;robotState, const <a class="el" href="namespaceoppt.html#a9590125085bd7d842e58c7e9549011f8">oppt::ActionSharedPtr</a> &amp;action)</td></tr>
<tr class="separator:a99b393af56b39f6212bafa9b6baf12e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a615aaf131e5cc7e7cf4548d4a5fd6a"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; std::unique_ptr&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#a7a615aaf131e5cc7e7cf4548d4a5fd6a">generateParticles</a> (<a class="el" href="classabt_1_1BeliefNode.html">abt::BeliefNode</a> *previousBelief, <a class="el" href="classabt_1_1BeliefNode.html">abt::BeliefNode</a> *nextBelief, <a class="el" href="classabt_1_1Point.html">abt::Action</a> const &amp;action, <a class="el" href="classabt_1_1Point.html">abt::Observation</a> const &amp;obs, long nParticles, std::vector&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> const * &gt; const &amp;previousParticles, std::vector&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> const * &gt; const &amp;currentParticles, const bool &amp;allowTerminalStates=false) override</td></tr>
<tr class="separator:a7a615aaf131e5cc7e7cf4548d4a5fd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77c4aa702ec740218204ccbc5fb5739"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae77c4aa702ec740218204ccbc5fb5739"></a>
virtual std::vector<br class="typebreak"/>
&lt; std::unique_ptr&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generateParticlesDefault</b> (<a class="el" href="classabt_1_1BeliefNode.html">abt::BeliefNode</a> *previousBelief, <a class="el" href="classabt_1_1Point.html">abt::Action</a> const &amp;action, <a class="el" href="classabt_1_1Point.html">abt::Observation</a> const &amp;obs, long nParticles, std::vector&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> const * &gt; const &amp;previousParticles, const bool &amp;allowTerminalStates=false)</td></tr>
<tr class="separator:ae77c4aa702ec740218204ccbc5fb5739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd19630d239624febbfb46754409e95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcd19630d239624febbfb46754409e95"></a>
virtual std::vector<br class="typebreak"/>
&lt; std::unique_ptr&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generateParticlesObservationModel</b> (<a class="el" href="classabt_1_1BeliefNode.html">abt::BeliefNode</a> *previousBelief, <a class="el" href="classabt_1_1BeliefNode.html">abt::BeliefNode</a> *nextBelief, <a class="el" href="classabt_1_1Point.html">abt::Action</a> const &amp;action, <a class="el" href="classabt_1_1Point.html">abt::Observation</a> const &amp;obs, long nParticles, std::vector&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> const * &gt; const &amp;previousParticles, std::vector&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> const * &gt; const &amp;nextParticles=std::vector&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> const * &gt;(), const bool &amp;allowTerminalStates=false)</td></tr>
<tr class="separator:afcd19630d239624febbfb46754409e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb1b86406df8851ee072a56fa82b84c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="defs_8hpp.html#abf68352991692944f34952d0069463bc">FloatType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#a1eb1b86406df8851ee072a56fa82b84c">getDefaultHeuristicValue</a> (<a class="el" href="classabt_1_1HistoryEntry.html">abt::HistoryEntry</a> const *entry, <a class="el" href="classabt_1_1Point.html">abt::State</a> const *state, <a class="el" href="classabt_1_1HistoricalData.html">abt::HistoricalData</a> const *data) override</td></tr>
<tr class="separator:a1eb1b86406df8851ee072a56fa82b84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3cd0e9d90223fd238f425b3f0c15b4"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1StateIndex.html">abt::StateIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#a4f3cd0e9d90223fd238f425b3f0c15b4">createStateIndex</a> () override</td></tr>
<tr class="separator:a4f3cd0e9d90223fd238f425b3f0c15b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2aabae1c9a82fe9a5b39858e36d56e1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#af2aabae1c9a82fe9a5b39858e36d56e1">applyChanges</a> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classabt_1_1ModelChange.html">abt::ModelChange</a> &gt;&gt; const &amp;changes, <a class="el" href="classabt_1_1Solver.html">abt::Solver</a> *solver) override</td></tr>
<tr class="separator:af2aabae1c9a82fe9a5b39858e36d56e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3007ce8db1232ad000a4dd17e0a9a52a"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1HistoricalData.html">abt::HistoricalData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#a3007ce8db1232ad000a4dd17e0a9a52a">createRootHistoricalData</a> () override</td></tr>
<tr class="separator:a3007ce8db1232ad000a4dd17e0a9a52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660a8eb9b05a2753c146134737047221"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1ActionPool.html">abt::ActionPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#a660a8eb9b05a2753c146134737047221">createActionPool</a> (<a class="el" href="classabt_1_1Solver.html">abt::Solver</a> *solver) override</td></tr>
<tr class="separator:a660a8eb9b05a2753c146134737047221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b501846abea49ed96afafb9e20d3a47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b501846abea49ed96afafb9e20d3a47"></a>
virtual <a class="el" href="defs_8hpp.html#abf68352991692944f34952d0069463bc">FloatType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>makeReward</b> (const <a class="el" href="namespaceoppt.html#ac6dea77f8ec8752ebcafaa953adb9ebf">oppt::PropagationResultSharedPtr</a> &amp;propagationResult)</td></tr>
<tr class="separator:a6b501846abea49ed96afafb9e20d3a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831092ca1f6e9910fd23d14ca0416f05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a831092ca1f6e9910fd23d14ca0416f05"></a>
virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classshared_1_1RobotObservation.html">shared::RobotObservation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>makeObservation</b> (<a class="el" href="namespaceoppt.html#a9590125085bd7d842e58c7e9549011f8">oppt::ActionSharedPtr</a> &amp;action, <a class="el" href="namespaceoppt.html#a63acd976c69e1f077392ae04f85ee5b5">oppt::RobotStateSharedPtr</a> &amp;robotState)</td></tr>
<tr class="separator:a831092ca1f6e9910fd23d14ca0416f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88c41bcd1fae7cfe76c90fcc74093fc"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1ObservationPool.html">abt::ObservationPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#af88c41bcd1fae7cfe76c90fcc74093fc">createObservationPool</a> (<a class="el" href="classabt_1_1Solver.html">abt::Solver</a> *solver) override</td></tr>
<tr class="separator:af88c41bcd1fae7cfe76c90fcc74093fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0323448b0ed00a2237a6486a23ea4f"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1Serializer.html">abt::Serializer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrobot_1_1RobotModel.html#abc0323448b0ed00a2237a6486a23ea4f">createSerializer</a> (<a class="el" href="classabt_1_1Solver.html">abt::Solver</a> *solver) override</td></tr>
<tr class="separator:abc0323448b0ed00a2237a6486a23ea4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0064db4140e2c13f7eea8e6bc5a15b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a0064db4140e2c13f7eea8e6bc5a15b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setRobotEnvironment</b> (<a class="el" href="classoppt_1_1RobotEnvironment.html">oppt::RobotEnvironment</a> *robotEnvironment)</td></tr>
<tr class="separator:a7a0064db4140e2c13f7eea8e6bc5a15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e1df441d7e35ef60f85f935f0e27fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36e1df441d7e35ef60f85f935f0e27fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setHeuristicPlugin</b> (const <a class="el" href="classoppt_1_1HeuristicPlugin.html">oppt::HeuristicPlugin</a> *heuristicPlugin)</td></tr>
<tr class="separator:a36e1df441d7e35ef60f85f935f0e27fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18fe13c69cec14ca24c5cc4fc3e3d1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae18fe13c69cec14ca24c5cc4fc3e3d1f"></a>
std::unique_ptr&lt; <a class="el" href="classabt_1_1Point.html">abt::Action</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>makeRobotAction</b> (const <a class="el" href="namespaceoppt.html#a9590125085bd7d842e58c7e9549011f8">oppt::ActionSharedPtr</a> &amp;opptAction)</td></tr>
<tr class="separator:ae18fe13c69cec14ca24c5cc4fc3e3d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95f85eb61cffb3e35550a445fd07708"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac95f85eb61cffb3e35550a445fd07708"></a>
<a class="el" href="namespaceoppt.html#a9590125085bd7d842e58c7e9549011f8">oppt::ActionSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getBaseAction</b> (const <a class="el" href="classabt_1_1Point.html">abt::Action</a> &amp;action) const </td></tr>
<tr class="separator:ac95f85eb61cffb3e35550a445fd07708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa231a69c919c7727a183e1504251777c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa231a69c919c7727a183e1504251777c"></a>
<a class="el" href="classoppt_1_1RobotEnvironment.html">oppt::RobotEnvironment</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRobotEnvironment</b> () const </td></tr>
<tr class="separator:aa231a69c919c7727a183e1504251777c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cab0310af9a6f1a7eb6aaff7766046"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41cab0310af9a6f1a7eb6aaff7766046"></a>
RandomEnginePtr&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomEngine</b> () const </td></tr>
<tr class="separator:a41cab0310af9a6f1a7eb6aaff7766046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e12fa4e9c120217530e227a3cf5299b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e12fa4e9c120217530e227a3cf5299b"></a>
<a class="el" href="classoppt_1_1Filter.html">Filter</a> *const&#160;</td><td class="memItemRight" valign="bottom"><b>getParticleFilter</b> () const </td></tr>
<tr class="separator:a2e12fa4e9c120217530e227a3cf5299b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classshared_1_1ModelWithProgramOptions"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classshared_1_1ModelWithProgramOptions')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classshared_1_1ModelWithProgramOptions.html">shared::ModelWithProgramOptions</a></td></tr>
<tr class="memitem:ae0afd56b84ad2752e5ccfe3db2f453b9 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#ae0afd56b84ad2752e5ccfe3db2f453b9">ModelWithProgramOptions</a> (std::string problemName, <a class="el" href="global_8hpp.html#a080b7731c061f9bafcf79d5e2f0c388a">RandomGenerator</a> *randGen, std::unique_ptr&lt; <a class="el" href="structoppt_1_1ABTExtendedOptions.html">oppt::ABTExtendedOptions</a> &gt; options)</td></tr>
<tr class="separator:ae0afd56b84ad2752e5ccfe3db2f453b9 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dbcb9b8d154f333001356de4fe22ee inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86dbcb9b8d154f333001356de4fe22ee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_NO_COPY_OR_MOVE</b> (<a class="el" href="classshared_1_1ModelWithProgramOptions.html">ModelWithProgramOptions</a>)</td></tr>
<tr class="separator:a86dbcb9b8d154f333001356de4fe22ee inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef0e7bedd2f15c4a3ccbf8c504171e2 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a5ef0e7bedd2f15c4a3ccbf8c504171e2">registerGeneratorParser</a> (std::string name, std::unique_ptr&lt; <a class="el" href="classshared_1_1Parser.html">Parser</a>&lt; std::unique_ptr&lt; <a class="el" href="classabt_1_1StepGeneratorFactory.html">abt::StepGeneratorFactory</a> &gt;&gt; &gt; parser)</td></tr>
<tr class="separator:a5ef0e7bedd2f15c4a3ccbf8c504171e2 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84c49b60d4a9f2b0937f411f7a81122 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#af84c49b60d4a9f2b0937f411f7a81122">registerHeuristicParser</a> (std::string name, std::unique_ptr&lt; <a class="el" href="classshared_1_1Parser.html">Parser</a>&lt; abt::HeuristicFunction &gt; &gt; parser)</td></tr>
<tr class="separator:af84c49b60d4a9f2b0937f411f7a81122 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc404b0f1eebd14ad3a4a9bcdd615859 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#adc404b0f1eebd14ad3a4a9bcdd615859">registerSearchParser</a> (std::string name, std::unique_ptr&lt; <a class="el" href="classshared_1_1Parser.html">Parser</a>&lt; std::unique_ptr&lt; <a class="el" href="classabt_1_1SearchStrategy.html">abt::SearchStrategy</a> &gt;&gt; &gt; parser)</td></tr>
<tr class="separator:adc404b0f1eebd14ad3a4a9bcdd615859 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b9cc1450f794c95e802de6b5dd2907 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a70b9cc1450f794c95e802de6b5dd2907">registerSelectRecommendedActionParser</a> (std::string name, std::unique_ptr&lt; <a class="el" href="classshared_1_1Parser.html">Parser</a>&lt; std::unique_ptr&lt; <a class="el" href="classabt_1_1SelectRecommendedActionStrategy.html">abt::SelectRecommendedActionStrategy</a> &gt;&gt; &gt; parser)</td></tr>
<tr class="separator:a70b9cc1450f794c95e802de6b5dd2907 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c848e4f01d3507423934a338d077fbc inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a4c848e4f01d3507423934a338d077fbc">registerEstimationParser</a> (std::string name, std::unique_ptr&lt; <a class="el" href="classshared_1_1Parser.html">Parser</a>&lt; std::unique_ptr&lt; <a class="el" href="classabt_1_1EstimationStrategy.html">abt::EstimationStrategy</a> &gt;&gt; &gt; parser)</td></tr>
<tr class="separator:a4c848e4f01d3507423934a338d077fbc inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79abafce56195c34c5e355231d0c412e inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1SearchStrategy.html">abt::SearchStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a79abafce56195c34c5e355231d0c412e">createSearchStrategy</a> (<a class="el" href="classabt_1_1Solver.html">abt::Solver</a> *solver) override</td></tr>
<tr class="separator:a79abafce56195c34c5e355231d0c412e inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff88c40c7d62c0ac955c3f8a1f88d085 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1SelectRecommendedActionStrategy.html">abt::SelectRecommendedActionStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#aff88c40c7d62c0ac955c3f8a1f88d085">createRecommendationSelectionStrategy</a> (<a class="el" href="classabt_1_1Solver.html">abt::Solver</a> *) override</td></tr>
<tr class="separator:aff88c40c7d62c0ac955c3f8a1f88d085 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7952f13b51618289da8ffdd3601a39f inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1EstimationStrategy.html">abt::EstimationStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#ae7952f13b51618289da8ffdd3601a39f">createEstimationStrategy</a> (<a class="el" href="classabt_1_1Solver.html">abt::Solver</a> *solver) override</td></tr>
<tr class="separator:ae7952f13b51618289da8ffdd3601a39f inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b03ad608eb2023493e9f5743d5513e inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1HistoryCorrector.html">abt::HistoryCorrector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a39b03ad608eb2023493e9f5743d5513e">createHistoryCorrector</a> (<a class="el" href="classabt_1_1Solver.html">abt::Solver</a> *solver) override</td></tr>
<tr class="separator:a39b03ad608eb2023493e9f5743d5513e inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58066922b45bb902b1ade6312abf2424 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual abt::HeuristicFunction&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a58066922b45bb902b1ade6312abf2424">getHeuristicFunction</a> () finaloverride</td></tr>
<tr class="separator:a58066922b45bb902b1ade6312abf2424 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classabt_1_1Model"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classabt_1_1Model')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classabt_1_1Model.html">abt::Model</a></td></tr>
<tr class="memitem:a62171cd889b05137a252f65e43a78417 inherit pub_methods_classabt_1_1Model"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabt_1_1Model.html#a62171cd889b05137a252f65e43a78417">Model</a> (std::string name, <a class="el" href="global_8hpp.html#a080b7731c061f9bafcf79d5e2f0c388a">RandomGenerator</a> *randGen, std::unique_ptr&lt; <a class="el" href="structoppt_1_1Options.html">oppt::Options</a> &gt; options)</td></tr>
<tr class="separator:a62171cd889b05137a252f65e43a78417 inherit pub_methods_classabt_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6e2d66a938d00b7f6eb3c2c7a30294 inherit pub_methods_classabt_1_1Model"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b6e2d66a938d00b7f6eb3c2c7a30294"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_NO_COPY_OR_MOVE</b> (<a class="el" href="classabt_1_1Model.html">Model</a>)</td></tr>
<tr class="separator:a5b6e2d66a938d00b7f6eb3c2c7a30294 inherit pub_methods_classabt_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774e049f0e4ea66180580bf4732aab71 inherit pub_methods_classabt_1_1Model"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a080b7731c061f9bafcf79d5e2f0c388a">RandomGenerator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabt_1_1Model.html#a774e049f0e4ea66180580bf4732aab71">getRandomGenerator</a> () const </td></tr>
<tr class="separator:a774e049f0e4ea66180580bf4732aab71 inherit pub_methods_classabt_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4b1bdc26c98d651550044a7db81827 inherit pub_methods_classabt_1_1Model"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoppt_1_1Options.html">oppt::Options</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabt_1_1Model.html#a2e4b1bdc26c98d651550044a7db81827">getOptions</a> () const </td></tr>
<tr class="separator:a2e4b1bdc26c98d651550044a7db81827 inherit pub_methods_classabt_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeff2b6c3e72dd937b57e47564b19a07 inherit pub_methods_classabt_1_1Model"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabt_1_1Model.html#afeff2b6c3e72dd937b57e47564b19a07">getName</a> () const </td></tr>
<tr class="separator:afeff2b6c3e72dd937b57e47564b19a07 inherit pub_methods_classabt_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0601b62c48a94816bfe17e3f50e51a2 inherit pub_methods_classabt_1_1Model"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0601b62c48a94816bfe17e3f50e51a2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>updateModel</b> (<a class="el" href="structabt_1_1Model_1_1StepResult.html">StepResult</a> &amp;stepResult, std::vector&lt; <a class="el" href="classabt_1_1Point.html">State</a> const * &gt; &amp;particles, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;particleColors)</td></tr>
<tr class="separator:ad0601b62c48a94816bfe17e3f50e51a2 inherit pub_methods_classabt_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cb5c7be285545ba9702475245faf4e inherit pub_methods_classabt_1_1Model"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; std::unique_ptr&lt; <a class="el" href="classabt_1_1Point.html">State</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabt_1_1Model.html#aa2cb5c7be285545ba9702475245faf4e">generateParticles</a> (<a class="el" href="classabt_1_1BeliefNode.html">BeliefNode</a> *previousBelief, <a class="el" href="classabt_1_1BeliefNode.html">BeliefNode</a> *nextBelief, <a class="el" href="classabt_1_1Point.html">Action</a> const &amp;action, <a class="el" href="classabt_1_1Point.html">Observation</a> const &amp;obs, long nParticles, std::vector&lt; <a class="el" href="classabt_1_1Point.html">State</a> const * &gt; const &amp;previousParticles, std::vector&lt; <a class="el" href="classabt_1_1Point.html">State</a> const * &gt; const &amp;currentParticles, const bool &amp;allowTerminalStates=false)</td></tr>
<tr class="separator:aa2cb5c7be285545ba9702475245faf4e inherit pub_methods_classabt_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab48c1d4bcb4db7208c7782e8d2b7c43 inherit pub_methods_classabt_1_1Model"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; std::unique_ptr&lt; <a class="el" href="classabt_1_1Point.html">State</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabt_1_1Model.html#aab48c1d4bcb4db7208c7782e8d2b7c43">generateParticles</a> (<a class="el" href="classabt_1_1BeliefNode.html">BeliefNode</a> *previousBelief, <a class="el" href="classabt_1_1Point.html">Action</a> const &amp;action, <a class="el" href="classabt_1_1Point.html">Observation</a> const &amp;obs, long nParticles)</td></tr>
<tr class="separator:aab48c1d4bcb4db7208c7782e8d2b7c43 inherit pub_methods_classabt_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41555318e0b661a6d67f365da299876e inherit pub_methods_classabt_1_1Model"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabt_1_1Model.html#a41555318e0b661a6d67f365da299876e">drawEnv</a> (std::ostream &amp;)</td></tr>
<tr class="separator:a41555318e0b661a6d67f365da299876e inherit pub_methods_classabt_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38f9e4ea554f95193579d52e71acf84 inherit pub_methods_classabt_1_1Model"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabt_1_1Model.html#aa38f9e4ea554f95193579d52e71acf84">drawSimulationState</a> (<a class="el" href="classabt_1_1BeliefNode.html">BeliefNode</a> const *belief, <a class="el" href="classabt_1_1Point.html">State</a> const &amp;state, std::ostream &amp;os)</td></tr>
<tr class="separator:aa38f9e4ea554f95193579d52e71acf84 inherit pub_methods_classabt_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6fa88df194425b6087745c2996f62e inherit pub_methods_classabt_1_1Model"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classabt_1_1Point.html">Action</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabt_1_1Model.html#a5d6fa88df194425b6087745c2996f62e">getRolloutAction</a> (<a class="el" href="classabt_1_1HistoryEntry.html">HistoryEntry</a> const *entry, <a class="el" href="classabt_1_1Point.html">State</a> const *state, <a class="el" href="classabt_1_1HistoricalData.html">HistoricalData</a> const *data)</td></tr>
<tr class="separator:a5d6fa88df194425b6087745c2996f62e inherit pub_methods_classabt_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5ea23d85681bb306f82d151ea380c1 inherit pub_methods_classabt_1_1Model"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa5ea23d85681bb306f82d151ea380c1"></a>
virtual <a class="el" href="classabt_1_1StateInfo.html">abt::StateInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sampleParticle</b> (const std::vector&lt; <a class="el" href="classabt_1_1StateInfo.html">abt::StateInfo</a> * &gt; &amp;stateInfos)</td></tr>
<tr class="separator:afa5ea23d85681bb306f82d151ea380c1 inherit pub_methods_classabt_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classshared_1_1ModelWithProgramOptions"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classshared_1_1ModelWithProgramOptions')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classshared_1_1ModelWithProgramOptions.html">shared::ModelWithProgramOptions</a></td></tr>
<tr class="memitem:a447577b6308e7a10da58d876597e38ed inherit pro_attribs_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshared_1_1ParserSet.html">ParserSet</a>&lt; std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1StepGeneratorFactory.html">abt::StepGeneratorFactory</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a447577b6308e7a10da58d876597e38ed">generatorParsers_</a></td></tr>
<tr class="separator:a447577b6308e7a10da58d876597e38ed inherit pro_attribs_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9f01025ec8e7c0278c3f835c43cfb0 inherit pro_attribs_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshared_1_1ParserSet.html">ParserSet</a>&lt; abt::HeuristicFunction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#afd9f01025ec8e7c0278c3f835c43cfb0">heuristicParsers_</a></td></tr>
<tr class="separator:afd9f01025ec8e7c0278c3f835c43cfb0 inherit pro_attribs_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad266ec4b97ea703fc47bb64016578579 inherit pro_attribs_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshared_1_1ParserSet.html">ParserSet</a>&lt; std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1SearchStrategy.html">abt::SearchStrategy</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#ad266ec4b97ea703fc47bb64016578579">searchParsers_</a></td></tr>
<tr class="separator:ad266ec4b97ea703fc47bb64016578579 inherit pro_attribs_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f0c88e301479dcb497a48bce0dae46 inherit pro_attribs_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshared_1_1ParserSet.html">ParserSet</a>&lt; std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1SelectRecommendedActionStrategy.html">abt::SelectRecommendedActionStrategy</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a53f0c88e301479dcb497a48bce0dae46">selectRecommendedActionParsers_</a></td></tr>
<tr class="separator:a53f0c88e301479dcb497a48bce0dae46 inherit pro_attribs_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad102b819da648644e9dedfcb62d37fc2 inherit pro_attribs_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshared_1_1ParserSet.html">ParserSet</a>&lt; std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classabt_1_1EstimationStrategy.html">abt::EstimationStrategy</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#ad102b819da648644e9dedfcb62d37fc2">estimationParsers_</a></td></tr>
<tr class="separator:ad102b819da648644e9dedfcb62d37fc2 inherit pro_attribs_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The implementation of the Model interface for the RockSample POMDP.</p>
<p>See this paper <a href="http://arxiv.org/ftp/arxiv/papers/1207/1207.4166.pdf">http://arxiv.org/ftp/arxiv/papers/1207/1207.4166.pdf</a> for a description of the RockSample problem.</p>
<p>This class inherits from <a class="el" href="classshared_1_1ModelWithProgramOptions.html">shared::ModelWithProgramOptions</a> in order to use custom text-parsing functionality to select many of the core ABT parameters, allowing the configuration options to be changed easily via the configuration interface without having to recompile the code. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab8f32daed872cd76554e069ea6e135a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">robot::RobotModel::RobotModel </td>
          <td>(</td>
          <td class="paramtype">RandomEnginePtr&#160;</td>
          <td class="paramname"><em>randGen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="structoppt_1_1ABTExtendedOptions.html">ABTExtendedOptions</a> &gt;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new <a class="el" href="classrobot_1_1RobotModel.html">RobotModel</a> instance with the given random number engine, and the given set of configuration options. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af2aabae1c9a82fe9a5b39858e36d56e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void robot::RobotModel::applyChanges </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classabt_1_1ModelChange.html">abt::ModelChange</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1Solver.html">abt::Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a number of changes to the model, and (if provided) to the given solver.</p>
<p>This is the core method that is used for the Model to inform the Solver of which states are affected, and hence need to be updated in whichever history sequences they occur. This should be done via the Solver's StatePool and StateIndex.</p>
<p>Since handling of changes is not mandatory, this method does nothing by default. However, if you do implement it, you must also implement <a class="el" href="classrobot_1_1RobotModel.html#af4b9a8f9d4a4757b4f856cbcc4204655">generateNextState()</a>, <a class="el" href="classrobot_1_1RobotModel.html#aa08c7fc9a544c84643904ba1ca924f02">generateObservation()</a>, and <a class="el" href="classrobot_1_1RobotModel.html#a5e64f248c714fc9278ba1840019f9439">generateReward()</a>. </p>

<p>Reimplemented from <a class="el" href="classabt_1_1Model.html#ae96f5a978261b24d6f732607e8f06ab3">abt::Model</a>.</p>

</div>
</div>
<a class="anchor" id="a660a8eb9b05a2753c146134737047221"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classabt_1_1ActionPool.html">abt::ActionPool</a> &gt; robot::RobotModel::createActionPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabt_1_1Solver.html">abt::Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an ActionPool, which manages actions and creates ActionMappings, for the given solver.</p>
<p>No default implementation is given, because there is no simple, general-purpose action mapping class. This is because the way in which actions are selected within the search tree depends strongly on the way in which the action space is specified.</p>
<p>However, for most purposes the EnumeratedActionMapping class should work well. This requires that the actions be enumerated [0, ..., nActions - 1], and that each action must be able to return its action number. </p>

<p>Implements <a class="el" href="classabt_1_1Model.html#a7f5b375e65d634b9d985c5e79f3faf05">abt::Model</a>.</p>

</div>
</div>
<a class="anchor" id="af88c41bcd1fae7cfe76c90fcc74093fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classabt_1_1ObservationPool.html">abt::ObservationPool</a> &gt; robot::RobotModel::createObservationPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabt_1_1Solver.html">abt::Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an ObservationPool, which manages observations and creates ObservationMappings, for the given solver.</p>
<p>The default implementation is DiscreteObservationPool, which stores the observations for each ActionNode in a hashtable. This should be effective for any problem with a discrete observation space. </p>

<p>Reimplemented from <a class="el" href="classabt_1_1Model.html#ae6980f75faa1f4aa4d30a5463f19f7a7">abt::Model</a>.</p>

</div>
</div>
<a class="anchor" id="a3007ce8db1232ad000a4dd17e0a9a52a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classabt_1_1HistoricalData.html">abt::HistoricalData</a> &gt; robot::RobotModel::createRootHistoricalData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates the historical data for the root node.</p>
<p>By default this returns a null pointer, as the HistoricalData interface is optional. </p>

<p>Reimplemented from <a class="el" href="classabt_1_1Model.html#a9faa33e076edea0a767951ac3436e02b">abt::Model</a>.</p>

</div>
</div>
<a class="anchor" id="abc0323448b0ed00a2237a6486a23ea4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classabt_1_1Serializer.html">abt::Serializer</a> &gt; robot::RobotModel::createSerializer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabt_1_1Solver.html">abt::Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a Serializer for the given solver.</p>
<p>By default this returns a null pointer. However, if you require serialization of the state of an ABT solver, you must implement a custom Serializer which will properly serialize the various clases you have implemented as part of your POMDP model. </p>

<p>Reimplemented from <a class="el" href="classabt_1_1Model.html#a325fd51af31931523caa52719cce5164">abt::Model</a>.</p>

</div>
</div>
<a class="anchor" id="a4f3cd0e9d90223fd238f425b3f0c15b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classabt_1_1StateIndex.html">abt::StateIndex</a> &gt; robot::RobotModel::createStateIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a StateIndex, which manages searching for states that have been used in a StatePool.</p>
<p>By default, this method uses an R*-Tree, as implemented in libspatialindex, in order to allow range-based queries for the states. </p>

<p>Implements <a class="el" href="classabt_1_1Model.html#a364bffd53bbd33078efbd33590e80017">abt::Model</a>.</p>

</div>
</div>
<a class="anchor" id="af4b9a8f9d4a4757b4f856cbcc4204655"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> &gt; robot::RobotModel::generateNextState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1TransitionParameters.html">abt::TransitionParameters</a> const *&#160;</td>
          <td class="paramname"><em>transitionParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates the next state, based on the state and action, and, if used, the transition parameters.</p>
<p>This method is only mandatory if you implement the <a class="el" href="classrobot_1_1RobotModel.html#af2aabae1c9a82fe9a5b39858e36d56e1">applyChanges()</a> method. </p>

<p>Reimplemented from <a class="el" href="classabt_1_1Model.html#aae4cc2508156dcdb7762dd69e7f5bd9b">abt::Model</a>.</p>

</div>
</div>
<a class="anchor" id="aa08c7fc9a544c84643904ba1ca924f02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classabt_1_1Point.html">abt::Observation</a> &gt; robot::RobotModel::generateObservation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::State</a> const *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1TransitionParameters.html">abt::TransitionParameters</a> const *&#160;</td>
          <td class="paramname"><em>transitionParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::State</a> const &amp;&#160;</td>
          <td class="paramname"><em>nextState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates an observation, given the action and resulting next state; optionally, the previous state and the transition parameters can also be used.</p>
<p>This method is only mandatory if you implement the <a class="el" href="classrobot_1_1RobotModel.html#af2aabae1c9a82fe9a5b39858e36d56e1">applyChanges()</a> method. </p>

<p>Reimplemented from <a class="el" href="classabt_1_1Model.html#a519f896e141ed4c88aba73776e906f4f">abt::Model</a>.</p>

</div>
</div>
<a class="anchor" id="a7a615aaf131e5cc7e7cf4548d4a5fd6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> &gt; &gt; robot::RobotModel::generateParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabt_1_1BeliefNode.html">abt::BeliefNode</a> *&#160;</td>
          <td class="paramname"><em>previousBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1BeliefNode.html">abt::BeliefNode</a> *&#160;</td>
          <td class="paramname"><em>nextBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::Observation</a> const &amp;&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> const * &gt; const &amp;&#160;</td>
          <td class="paramname"><em>previousParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> const * &gt; const &amp;&#160;</td>
          <td class="paramname"><em>currentParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>allowTerminalStates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates particles for RockSample using a particle filter from the previous belief.</p>
<p>For each previous particle, possible next states are calculated based on consistency with the given action and observation. These next states are then added to the output vector in accordance with their probability of having been generated. </p>

</div>
</div>
<a class="anchor" id="a5e64f248c714fc9278ba1840019f9439"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8hpp.html#abf68352991692944f34952d0069463bc">FloatType</a> robot::RobotModel::generateReward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1TransitionParameters.html">abt::TransitionParameters</a> const *&#160;</td>
          <td class="paramname"><em>transitionParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::State</a> const *&#160;</td>
          <td class="paramname"><em>nextState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the reward for the given state, action; optionally this also includes transition parameters and the next state - if they aren't being used it is OK to use nullptr for those inputs.</p>
<p>This method is only mandatory if you implement the <a class="el" href="classrobot_1_1RobotModel.html#af2aabae1c9a82fe9a5b39858e36d56e1">applyChanges()</a> method. </p>

<p>Reimplemented from <a class="el" href="classabt_1_1Model.html#a4dd818a01885c8b9580a000ef1804a81">abt::Model</a>.</p>

</div>
</div>
<a class="anchor" id="a8bd8c83847ada3199c1d4bf87ade87d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structabt_1_1Model_1_1StepResult.html">abt::Model::StepResult</a> robot::RobotModel::generateStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a full StepResult, including the next state, an observation, and the reward, as well as any transition parameters used.</p>
<p>For convenience, the action taken is also included in the result, as well as a flag for whether or not the resulting next state is terminal. </p>

<p>Implements <a class="el" href="classabt_1_1Model.html#a020a224911c9d1539548d28b08dec702">abt::Model</a>.</p>

</div>
</div>
<a class="anchor" id="a64dfa57e38e123c67fdae99043626d15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classabt_1_1TransitionParameters.html">abt::TransitionParameters</a> &gt; robot::RobotModel::generateTransition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates the parameters for a next-state transition, if any are being used.</p>
<p>This method is optional - the default implementation simply returns nullptr. </p>

<p>Reimplemented from <a class="el" href="classabt_1_1Model.html#a8e24d423cc75dd4b47b99a0c5cdbfde5">abt::Model</a>.</p>

</div>
</div>
<a class="anchor" id="a1eb1b86406df8851ee072a56fa82b84c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8hpp.html#abf68352991692944f34952d0069463bc">FloatType</a> robot::RobotModel::getDefaultHeuristicValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabt_1_1HistoryEntry.html">abt::HistoryEntry</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::State</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabt_1_1HistoricalData.html">abt::HistoricalData</a> const *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A simpler interface to define a default heuristic function for a subclass.</p>
<p>If you set options_-&gt;sharedHeuristic to "default()" this is the heuristic function that will be used. </p>

<p>Reimplemented from <a class="el" href="classshared_1_1ModelWithProgramOptions.html#af554fb47572c26adf2aed0ebfa13520a">shared::ModelWithProgramOptions</a>.</p>

</div>
</div>
<a class="anchor" id="a3bc1463779eced9f629dc4b98132468d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool robot::RobotModel::isTerminal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true iff the given state is terminal. </p>

<p>Implements <a class="el" href="classabt_1_1Model.html#a944c5844d9bd55966a1efdb7bbc6e220">abt::Model</a>.</p>

</div>
</div>
<a class="anchor" id="a94e3429befd348efaf10320a329106d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool robot::RobotModel::isValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabt_1_1Point.html">abt::State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true iff the given state is valid. </p>

<p>Implements <a class="el" href="classabt_1_1Model.html#a8b3a370a75a6967d979942a14dda7364">abt::Model</a>.</p>

</div>
</div>
<a class="anchor" id="a4fa75446992255a6b4d81667dd7ebebb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> &gt; robot::RobotModel::sampleAnInitState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Samples an initial state from the initial belief. </p>

<p>Implements <a class="el" href="classabt_1_1Model.html#a0eb0df0ae44f89107bb4adcd52e5aa7b">abt::Model</a>.</p>

</div>
</div>
<a class="anchor" id="a430074b87e12d15523b2ee8ab5573d85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classabt_1_1Point.html">abt::State</a> &gt; robot::RobotModel::sampleStateUninformed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a state uniformly at random. </p>

<p>Implements <a class="el" href="classabt_1_1Model.html#af3a1cc281e7f2ecca46c3509f8dd5942">abt::Model</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/marcus/PhD/scripts/oppt_devel2/src/solvers/ABT/robotModel/<a class="el" href="RobotModel_8hpp_source.html">RobotModel.hpp</a></li>
<li>/home/marcus/PhD/scripts/oppt_devel2/src/solvers/ABT/robotModel/RobotModel.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 27 2018 17:49:15 for OPPT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
